import type { AssertRest, Evaluate } from '@sinclair/typebox/build/require/type/helpers';
import type { TSchema, SchemaOptions } from '@sinclair/typebox/build/require/type/schema';
import { type TAny } from '@sinclair/typebox/build/require/type/any';
import { type TBigInt } from '@sinclair/typebox/build/require/type/bigint';
import { type TDate } from '@sinclair/typebox/build/require/type/date';
import { type TFunction } from '@sinclair/typebox/build/require/type/function';
import { type TLiteral } from '@sinclair/typebox/build/require/type/literal';
import { type TNever } from '@sinclair/typebox/build/require/type/never';
import { type TNull } from '@sinclair/typebox/build/require/type/null';
import { type TObject } from '@sinclair/typebox/build/require/type/object';
import { type TSymbol } from '@sinclair/typebox/build/require/type/symbol';
import { type TTuple } from '@sinclair/typebox/build/require/type/tuple';
import { type TReadonly } from '@sinclair/typebox/build/require/type/readonly';
import { type TUndefined } from '@sinclair/typebox/build/require/type/undefined';
import { type TUint8Array } from '@sinclair/typebox/build/require/type/uint8array';
import { type TUnknown } from '@sinclair/typebox/build/require/type/unknown';
type TFromArray<T extends readonly unknown[]> = T extends readonly [infer L extends unknown, ...infer R extends unknown[]] ? [FromValue<L, false>, ...TFromArray<R>] : T;
type TFromProperties<T extends Record<PropertyKey, unknown>> = {
    -readonly [K in keyof T]: FromValue<T[K], false> extends infer R extends TSchema ? TReadonly<R> : TReadonly<TNever>;
};
type TConditionalReadonly<T extends TSchema, Root extends boolean> = Root extends true ? T : TReadonly<T>;
type FromValue<T, Root extends boolean> = T extends AsyncIterableIterator<unknown> ? TConditionalReadonly<TAny, Root> : T extends IterableIterator<unknown> ? TConditionalReadonly<TAny, Root> : T extends readonly unknown[] ? TReadonly<TTuple<AssertRest<TFromArray<T>>>> : T extends Uint8Array ? TUint8Array : T extends Date ? TDate : T extends Record<PropertyKey, unknown> ? TConditionalReadonly<TObject<Evaluate<TFromProperties<T>>>, Root> : T extends Function ? TConditionalReadonly<TFunction<[], TUnknown>, Root> : T extends undefined ? TUndefined : T extends null ? TNull : T extends symbol ? TSymbol : T extends number ? TLiteral<T> : T extends boolean ? TLiteral<T> : T extends string ? TLiteral<T> : T extends bigint ? TBigInt : TObject<{}>;
declare function FromValue<T, Root extends boolean>(value: T, root: Root): FromValue<T, Root>;
export type TConst<T> = FromValue<T, true>;
/** `[JavaScript]` Creates a readonly const type from the given value. */
export declare function Const</* const (not supported in 4.0) */ T>(T: T, options?: SchemaOptions): TConst<T>;
export {};
