import type { TSchema } from '@sinclair/typebox/build/require/type/schema';
import type { Evaluate } from '@sinclair/typebox/build/require/type/helpers';
import type { TTuple } from '@sinclair/typebox/build/require/type/tuple';
import type { TIntersect } from '@sinclair/typebox/build/require/type/intersect';
import type { TUnion } from '@sinclair/typebox/build/require/type/union';
import type { TPromise } from '@sinclair/typebox/build/require/type/promise';
import type { TAsyncIterator } from '@sinclair/typebox/build/require/type/async-iterator';
import type { TIterator } from '@sinclair/typebox/build/require/type/iterator';
import type { TArray } from '@sinclair/typebox/build/require/type/array';
import type { TConstructor } from '@sinclair/typebox/build/require/type/constructor';
import type { TFunction } from '@sinclair/typebox/build/require/type/function';
import type { TRef } from '@sinclair/typebox/build/require/type/ref';
import type { TObject, TProperties } from '@sinclair/typebox/build/require/type/object';
export type TFromRest<T extends TSchema[], Acc extends TSchema[] = []> = (T extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TFromRest<R, [...Acc, TDeref<L>]> : Acc);
type FromProperties<T extends TProperties> = Evaluate<{
    [K in keyof T]: TDeref<T[K]>;
}>;
declare function FromProperties(properties: TProperties, references: TSchema[]): TProperties;
export type TDeref<T extends TSchema> = T extends TConstructor<infer S extends TSchema[], infer R extends TSchema> ? TConstructor<TFromRest<S>, TDeref<R>> : T extends TFunction<infer S extends TSchema[], infer R extends TSchema> ? TFunction<TFromRest<S>, TDeref<R>> : T extends TIntersect<infer S extends TSchema[]> ? TIntersect<TFromRest<S>> : T extends TUnion<infer S extends TSchema[]> ? TUnion<TFromRest<S>> : T extends TTuple<infer S extends TSchema[]> ? TTuple<TFromRest<S>> : T extends TObject<infer S extends TProperties> ? TObject<FromProperties<S>> : T extends TArray<infer S extends TSchema> ? TArray<TDeref<S>> : T extends TPromise<infer S extends TSchema> ? TPromise<TDeref<S>> : T extends TAsyncIterator<infer S extends TSchema> ? TAsyncIterator<TDeref<S>> : T extends TIterator<infer S extends TSchema> ? TIterator<TDeref<S>> : T extends TRef<infer S extends TSchema> ? TDeref<S> : T;
/** `[Json]` Creates a dereferenced type */
export declare function Deref<T extends TSchema>(schema: T, references: TSchema[]): TDeref<T>;
export {};
