import type { Evaluate } from '@sinclair/typebox/build/require/type/helpers';
import type { TOptional } from '@sinclair/typebox/build/require/type/optional';
import type { TReadonly } from '@sinclair/typebox/build/require/type/readonly';
import type { TArray } from '@sinclair/typebox/build/require/type/array';
import type { TAsyncIterator } from '@sinclair/typebox/build/require/type/async-iterator';
import type { TConstructor } from '@sinclair/typebox/build/require/type/constructor';
import type { TEnum } from '@sinclair/typebox/build/require/type/enum';
import type { TFunction } from '@sinclair/typebox/build/require/type/function';
import type { TIntersect } from '@sinclair/typebox/build/require/type/intersect';
import type { TIterator } from '@sinclair/typebox/build/require/type/iterator';
import type { TNot } from '@sinclair/typebox/build/require/type/not';
import type { TObject, TProperties } from '@sinclair/typebox/build/require/type/object';
import type { TPromise } from '@sinclair/typebox/build/require/type/promise';
import type { TRecursive } from '@sinclair/typebox/build/require/type/recursive';
import type { TRecord } from '@sinclair/typebox/build/require/type/record';
import type { TRef } from '@sinclair/typebox/build/require/type/ref';
import type { TTuple } from '@sinclair/typebox/build/require/type/tuple';
import type { TUnion } from '@sinclair/typebox/build/require/type/union';
import type { TUnsafe } from '@sinclair/typebox/build/require/type/unsafe';
import type { TSchema } from '@sinclair/typebox/build/require/type/schema';
import type { TTransform } from '@sinclair/typebox/build/require/type/transform';
export type TDecodeProperties<T extends TProperties> = {
    [K in keyof T]: TDecodeType<T[K]>;
};
export type TDecodeRest<T extends TSchema[], Acc extends TSchema[] = []> = T extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TDecodeRest<R, [...Acc, TDecodeType<L>]> : Acc;
export type TDecodeType<T extends TSchema> = (T extends TOptional<infer S extends TSchema> ? TOptional<TDecodeType<S>> : T extends TReadonly<infer S extends TSchema> ? TReadonly<TDecodeType<S>> : T extends TTransform<infer _, infer R> ? TUnsafe<R> : T extends TArray<infer S extends TSchema> ? TArray<TDecodeType<S>> : T extends TAsyncIterator<infer S extends TSchema> ? TAsyncIterator<TDecodeType<S>> : T extends TConstructor<infer P extends TSchema[], infer R extends TSchema> ? TConstructor<TDecodeRest<P>, TDecodeType<R>> : T extends TEnum<infer S> ? TEnum<S> : T extends TFunction<infer P extends TSchema[], infer R extends TSchema> ? TFunction<TDecodeRest<P>, TDecodeType<R>> : T extends TIntersect<infer S extends TSchema[]> ? TIntersect<TDecodeRest<S>> : T extends TIterator<infer S extends TSchema> ? TIterator<TDecodeType<S>> : T extends TNot<infer S extends TSchema> ? TNot<TDecodeType<S>> : T extends TObject<infer S> ? TObject<Evaluate<TDecodeProperties<S>>> : T extends TPromise<infer S extends TSchema> ? TPromise<TDecodeType<S>> : T extends TRecord<infer K, infer S> ? TRecord<K, TDecodeType<S>> : T extends TRecursive<infer S extends TSchema> ? TRecursive<TDecodeType<S>> : T extends TRef<infer S extends TSchema> ? TRef<TDecodeType<S>> : T extends TTuple<infer S extends TSchema[]> ? TTuple<TDecodeRest<S>> : T extends TUnion<infer S extends TSchema[]> ? TUnion<TDecodeRest<S>> : T);
/** Creates an decoded static type from a TypeBox type */
export type StaticDecode<T extends TSchema, P extends unknown[] = []> = Static<TDecodeType<T>, P>;
/** Creates an encoded static type from a TypeBox type */
export type StaticEncode<T extends TSchema, P extends unknown[] = []> = Static<T, P>;
/** Creates a static type from a TypeBox type */
export type Static<T extends TSchema, P extends unknown[] = []> = (T & {
    params: P;
})['static'];
