import type { TSchema } from '@sinclair/typebox/build/require/type/schema';
import type { Ensure, Evaluate, Assert } from '@sinclair/typebox/build/require/type/helpers';
import { type TArray } from '@sinclair/typebox/build/require/type/array';
import { type TAsyncIterator } from '@sinclair/typebox/build/require/type/async-iterator';
import { type TConstructor } from '@sinclair/typebox/build/require/type/constructor';
import { type TFunction } from '@sinclair/typebox/build/require/type/function';
import { type TIndexPropertyKeys } from '@sinclair/typebox/build/require/type/indexed';
import { type TIntersect } from '@sinclair/typebox/build/require/type/intersect';
import { type TIterator } from '@sinclair/typebox/build/require/type/iterator';
import { type TLiteral, type TLiteralValue } from '@sinclair/typebox/build/require/type/literal';
import { type TObject, type TProperties, type ObjectOptions } from '@sinclair/typebox/build/require/type/object';
import { type TOptional } from '@sinclair/typebox/build/require/type/optional';
import { type TPromise } from '@sinclair/typebox/build/require/type/promise';
import { type TReadonly } from '@sinclair/typebox/build/require/type/readonly';
import { type TTuple } from '@sinclair/typebox/build/require/type/tuple';
import { type TUnion } from '@sinclair/typebox/build/require/type/union';
import { type TSetIncludes } from '@sinclair/typebox/build/require/type/sets';
import { type TMappedResult } from '@sinclair/typebox/build/require/type/mapped/mapped-result';
import type { TMappedKey } from '@sinclair/typebox/build/require/type/mapped/mapped-key';
type TFromMappedResult<K extends PropertyKey, P extends TProperties> = (K extends keyof P ? FromSchemaType<K, P[K]> : TMappedResult<P>);
type TMappedKeyToKnownMappedResultProperties<K extends PropertyKey> = {
    [_ in K]: TLiteral<Assert<K, TLiteralValue>>;
};
type TMappedKeyToUnknownMappedResultProperties<P extends PropertyKey[], Acc extends TProperties = {}> = (P extends [infer L extends PropertyKey, ...infer R extends PropertyKey[]] ? TMappedKeyToUnknownMappedResultProperties<R, Acc & {
    [_ in L]: TLiteral<Assert<L, TLiteralValue>>;
}> : Acc);
type TMappedKeyToMappedResultProperties<K extends PropertyKey, P extends PropertyKey[]> = (TSetIncludes<P, K> extends true ? TMappedKeyToKnownMappedResultProperties<K> : TMappedKeyToUnknownMappedResultProperties<P>);
type TFromMappedKey<K extends PropertyKey, P extends PropertyKey[], R extends TProperties = TMappedKeyToMappedResultProperties<K, P>> = (TFromMappedResult<K, R>);
type TFromRest<K extends PropertyKey, T extends TSchema[], Acc extends TSchema[] = []> = (T extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TFromRest<K, R, [...Acc, FromSchemaType<K, L>]> : Acc);
type FromProperties<K extends PropertyKey, T extends TProperties, R extends TProperties = Evaluate<{
    [K2 in keyof T]: FromSchemaType<K, T[K2]>;
}>> = R;
declare function FromProperties<K extends PropertyKey, T extends TProperties>(K: K, T: T): FromProperties<K, T>;
type FromSchemaType<K extends PropertyKey, T extends TSchema> = (T extends TReadonly<infer S> ? TReadonly<FromSchemaType<K, S>> : T extends TOptional<infer S> ? TOptional<FromSchemaType<K, S>> : T extends TMappedResult<infer P> ? TFromMappedResult<K, P> : T extends TMappedKey<infer P> ? TFromMappedKey<K, P> : T extends TConstructor<infer S extends TSchema[], infer R extends TSchema> ? TConstructor<TFromRest<K, S>, FromSchemaType<K, R>> : T extends TFunction<infer S extends TSchema[], infer R extends TSchema> ? TFunction<TFromRest<K, S>, FromSchemaType<K, R>> : T extends TAsyncIterator<infer S> ? TAsyncIterator<FromSchemaType<K, S>> : T extends TIterator<infer S> ? TIterator<FromSchemaType<K, S>> : T extends TIntersect<infer S> ? TIntersect<TFromRest<K, S>> : T extends TUnion<infer S> ? TUnion<TFromRest<K, S>> : T extends TTuple<infer S> ? TTuple<TFromRest<K, S>> : T extends TObject<infer S> ? TObject<FromProperties<K, S>> : T extends TArray<infer S> ? TArray<FromSchemaType<K, S>> : T extends TPromise<infer S> ? TPromise<FromSchemaType<K, S>> : T);
declare function FromSchemaType<K extends PropertyKey, T extends TSchema>(K: K, T: T): FromSchemaType<K, T>;
export type TMappedFunctionReturnType<K extends PropertyKey[], T extends TSchema, Acc extends TProperties = {}> = (K extends [infer L extends PropertyKey, ...infer R extends PropertyKey[]] ? TMappedFunctionReturnType<R, T, Acc & {
    [_ in L]: FromSchemaType<L, T>;
}> : Acc);
export declare function MappedFunctionReturnType<K extends PropertyKey[], T extends TSchema>(K: [...K], T: T, Acc?: TProperties): TMappedFunctionReturnType<K, T>;
export type TMappedFunction<K extends PropertyKey[], I = TMappedKey<K>> = (T: I) => TSchema;
export type TMapped<K extends PropertyKey[], F extends TMappedFunction<K>, R extends TProperties = Evaluate<TMappedFunctionReturnType<K, ReturnType<F>>>> = Ensure<TObject<R>>;
/** `[Json]` Creates a Mapped object type */
export declare function Mapped<K extends TSchema, I extends PropertyKey[] = TIndexPropertyKeys<K>, F extends TMappedFunction<I> = TMappedFunction<I>, R extends TMapped<I, F> = TMapped<I, F>>(key: K, map: F, options?: ObjectOptions): R;
/** `[Json]` Creates a Mapped object type */
export declare function Mapped<K extends PropertyKey[], F extends TMappedFunction<K> = TMappedFunction<K>, R extends TMapped<K, F> = TMapped<K, F>>(key: [...K], map: F, options?: ObjectOptions): R;
export {};
